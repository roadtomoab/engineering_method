'''
â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–
âœï¸ Description
â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”
Q. Given a binary search tree and a target integer, check if the tree contains a target.

Examples:
â€¢ Given a binary search tree:
                  8
                /   \
               3     10
              / \      \
             1   6      14
                       /
                     13
â€¢ For target: 4 // returns False
â€¢ For target: 14 // returns True

ðŸ”Ž EXPLORE
What are some other insightful & revealing test cases?
 

ðŸ§  BRAINSTORM
What approaches could work?
Algorithm 1:
Time: O()
Space: O()
 

ðŸ“† PLAN
Outline of algorithm #: 
 

ðŸ› ï¸ IMPLEMENT
Write your algorithm.
 

ðŸ§ª VERIFY
Run tests. Methodically debug & analyze issues.

'''

class TreeNode:
    def __init__(self, value = 0, left = None, right = None):
        self.value = value
        self.left = left
        self.right = right

def search_bst(root: TreeNode, target: int) -> bool:
    
    curr = root

    while curr:
        if curr.value == target:
            return True

        if target > curr.value:
            curr = curr.right
        else:
            curr = curr.left
    
    return False

# Test Cases
tree = TreeNode(8, TreeNode(3, TreeNode(1), TreeNode(6)), TreeNode(10, None, TreeNode(14, TreeNode(13))))
print(search_bst(None, 1), False)
print(search_bst(tree, 1), True)
print(search_bst(tree, 14), True)
print(search_bst(tree, 2), False)
print(search_bst(tree, 13), True)