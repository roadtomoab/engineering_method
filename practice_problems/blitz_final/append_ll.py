'''
â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–
âœï¸ Description
â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”
Q. Given a linked list, append an element with a target value to the list iteratively.

Examples:
â€¢ Given a linked list: 1 âžž 4 âžž 5, target: 7 // returns 1 âžž 4 âžž 5 âžž 7
â€¢ Given a linked list: 0, target 7 // returns 0 âžž 7


ðŸ”Ž EXPLORE
What are some other insightful & revealing test cases?
 

ðŸ§  BRAINSTORM
What approaches could work?
Algorithm 1:
Time: O()
Space: O()
 

ðŸ“† PLAN
Outline of algorithm #: 
 

ðŸ› ï¸ IMPLEMENT
Write your algorithm.
 

ðŸ§ª VERIFY
Run tests. Methodically debug & analyze issues.

'''

class ListNode:
    def __init__(self, value = 0, next = None): 
        self.value = value
        self.next = next
        
def arrayify(head):
    array = []
    ptr = head
    while ptr != None:
        array.append(ptr.value)
        ptr = ptr.next
    return array

def append(node: ListNode, target: int) -> ListNode:

    if node is None:
        return ListNode(target)
    
    cur = node

    while cur:
        if cur.next is None:
            cur.next = ListNode(7)
            break
        cur = cur.next
    
    return node
    

LL1 = ListNode(1, ListNode(4, ListNode(5)))
print(arrayify(append(None, 1))) # [1]
print(arrayify(append(LL1, 7))) # [1, 4, 5, 7]
print(arrayify(append(ListNode(), 7))) # [0, 7]